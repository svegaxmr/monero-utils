package com.svega.moneroutils.crypto.slowhash

@ExperimentalUnsignedTypes
data class JHHashState(
    var hashbitlen: Int,	   	              /*the message digest size*/
    var databitlen: Int,    /*the message size in bits*/
    var datasize_in_buffer: Int,      /*the size of the message remained in buffer; assumed to be multiple of 8bits except for the last partial block at the end of the message*/
    val x: Array<ULongArray> = cx(),    /*the 1024-bit state, ( x[i][0] || x[i][1] ) is the ith row of the state in the pseudocode*/
    val buffer: Scratchpad = UByteArrayScratchpad(64),         /*the 512-bit message block to be hashed;*/
    val bp: UBytePointer = buffer.getPointer(0),
    val bpl: ULongPointer = buffer.getPointer(0).toULongPointer()
){
    companion object {
        private fun cx() = Array(8){ ULongArray(2)}
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as JHHashState

        if (hashbitlen != other.hashbitlen) return false
        if (databitlen != other.databitlen) return false
        if (datasize_in_buffer != other.datasize_in_buffer) return false
        if (!x.contentEquals(other.x)) return false
        if (buffer != other.buffer) return false

        return true
    }

    override fun hashCode(): Int {
        var result = hashbitlen
        result = 31 * result + databitlen.hashCode()
        result = 31 * result + datasize_in_buffer.hashCode()
        result = 31 * result + x.contentHashCode()
        result = 31 * result + buffer.hashCode()
        return result
    }
}

@ExperimentalUnsignedTypes
object JH {
    private val JH256_H0 = ubyteArrayOf(0xebu, 0x98u, 0xa3u, 0x41u, 0x2cu, 0x20u, 0xd3u, 0xebu, 0x92u, 0xcdu, 0xbeu, 0x7bu, 0x9cu, 0xb2u, 0x45u, 0xc1u, 0x1cu, 0x93u, 0x51u, 0x91u, 0x60u, 0xd4u, 0xc7u, 0xfau, 0x26u, 0x0u, 0x82u, 0xd6u, 0x7eu, 0x50u, 0x8au, 0x3u, 0xa4u, 0x23u, 0x9eu, 0x26u, 0x77u, 0x26u, 0xb9u, 0x45u, 0xe0u, 0xfbu, 0x1au, 0x48u, 0xd4u, 0x1au, 0x94u, 0x77u, 0xcdu, 0xb5u, 0xabu, 0x26u, 0x2u, 0x6bu, 0x17u, 0x7au, 0x56u, 0xf0u, 0x24u, 0x42u, 0xfu, 0xffu, 0x2fu, 0xa8u, 0x71u, 0xa3u, 0x96u, 0x89u, 0x7fu, 0x2eu, 0x4du, 0x75u, 0x1du, 0x14u, 0x49u, 0x8u, 0xf7u, 0x7du, 0xe2u, 0x62u, 0x27u, 0x76u, 0x95u, 0xf7u, 0x76u, 0x24u, 0x8fu, 0x94u, 0x87u, 0xd5u, 0xb6u, 0x57u, 0x47u, 0x80u, 0x29u, 0x6cu, 0x5cu, 0x5eu, 0x27u, 0x2du, 0xacu, 0x8eu, 0xdu, 0x6cu, 0x51u, 0x84u, 0x50u, 0xc6u, 0x57u, 0x5u, 0x7au, 0xfu, 0x7bu, 0xe4u, 0xd3u, 0x67u, 0x70u, 0x24u, 0x12u, 0xeau, 0x89u, 0xe3u, 0xabu, 0x13u, 0xd3u, 0x1cu, 0xd7u, 0x69u)
    private val E8_bitslice_roundconstant = Array(42){when(it){
        0 -> UByteArrayScratchpad(ubyteArrayOf(0x72u,0xd5u,0xdeu,0xa2u,0xdfu,0x15u,0xf8u,0x67u,0x7bu,0x84u,0x15u,0xau,0xb7u,0x23u,0x15u,0x57u,0x81u,0xabu,0xd6u,0x90u,0x4du,0x5au,0x87u,0xf6u,0x4eu,0x9fu,0x4fu,0xc5u,0xc3u,0xd1u,0x2bu,0x40u))
        1 -> UByteArrayScratchpad(ubyteArrayOf(0xeau,0x98u,0x3au,0xe0u,0x5cu,0x45u,0xfau,0x9cu,0x3u,0xc5u,0xd2u,0x99u,0x66u,0xb2u,0x99u,0x9au,0x66u,0x2u,0x96u,0xb4u,0xf2u,0xbbu,0x53u,0x8au,0xb5u,0x56u,0x14u,0x1au,0x88u,0xdbu,0xa2u,0x31u))
        2 -> UByteArrayScratchpad(ubyteArrayOf(0x3u,0xa3u,0x5au,0x5cu,0x9au,0x19u,0xeu,0xdbu,0x40u,0x3fu,0xb2u,0xau,0x87u,0xc1u,0x44u,0x10u,0x1cu,0x5u,0x19u,0x80u,0x84u,0x9eu,0x95u,0x1du,0x6fu,0x33u,0xebu,0xadu,0x5eu,0xe7u,0xcdu,0xdcu))
        3 -> UByteArrayScratchpad(ubyteArrayOf(0x10u,0xbau,0x13u,0x92u,0x2u,0xbfu,0x6bu,0x41u,0xdcu,0x78u,0x65u,0x15u,0xf7u,0xbbu,0x27u,0xd0u,0xau,0x2cu,0x81u,0x39u,0x37u,0xaau,0x78u,0x50u,0x3fu,0x1au,0xbfu,0xd2u,0x41u,0x0u,0x91u,0xd3u))
        4 -> UByteArrayScratchpad(ubyteArrayOf(0x42u,0x2du,0x5au,0xdu,0xf6u,0xccu,0x7eu,0x90u,0xddu,0x62u,0x9fu,0x9cu,0x92u,0xc0u,0x97u,0xceu,0x18u,0x5cu,0xa7u,0xbu,0xc7u,0x2bu,0x44u,0xacu,0xd1u,0xdfu,0x65u,0xd6u,0x63u,0xc6u,0xfcu,0x23u))
        5 -> UByteArrayScratchpad(ubyteArrayOf(0x97u,0x6eu,0x6cu,0x3u,0x9eu,0xe0u,0xb8u,0x1au,0x21u,0x5u,0x45u,0x7eu,0x44u,0x6cu,0xecu,0xa8u,0xeeu,0xf1u,0x3u,0xbbu,0x5du,0x8eu,0x61u,0xfau,0xfdu,0x96u,0x97u,0xb2u,0x94u,0x83u,0x81u,0x97u))
        6 -> UByteArrayScratchpad(ubyteArrayOf(0x4au,0x8eu,0x85u,0x37u,0xdbu,0x3u,0x30u,0x2fu,0x2au,0x67u,0x8du,0x2du,0xfbu,0x9fu,0x6au,0x95u,0x8au,0xfeu,0x73u,0x81u,0xf8u,0xb8u,0x69u,0x6cu,0x8au,0xc7u,0x72u,0x46u,0xc0u,0x7fu,0x42u,0x14u))
        7 -> UByteArrayScratchpad(ubyteArrayOf(0xc5u,0xf4u,0x15u,0x8fu,0xbdu,0xc7u,0x5eu,0xc4u,0x75u,0x44u,0x6fu,0xa7u,0x8fu,0x11u,0xbbu,0x80u,0x52u,0xdeu,0x75u,0xb7u,0xaeu,0xe4u,0x88u,0xbcu,0x82u,0xb8u,0x0u,0x1eu,0x98u,0xa6u,0xa3u,0xf4u))
        8 -> UByteArrayScratchpad(ubyteArrayOf(0x8eu,0xf4u,0x8fu,0x33u,0xa9u,0xa3u,0x63u,0x15u,0xaau,0x5fu,0x56u,0x24u,0xd5u,0xb7u,0xf9u,0x89u,0xb6u,0xf1u,0xedu,0x20u,0x7cu,0x5au,0xe0u,0xfdu,0x36u,0xcau,0xe9u,0x5au,0x6u,0x42u,0x2cu,0x36u))
        9 -> UByteArrayScratchpad(ubyteArrayOf(0xceu,0x29u,0x35u,0x43u,0x4eu,0xfeu,0x98u,0x3du,0x53u,0x3au,0xf9u,0x74u,0x73u,0x9au,0x4bu,0xa7u,0xd0u,0xf5u,0x1fu,0x59u,0x6fu,0x4eu,0x81u,0x86u,0xeu,0x9du,0xadu,0x81u,0xafu,0xd8u,0x5au,0x9fu))
        10 -> UByteArrayScratchpad(ubyteArrayOf(0xa7u,0x5u,0x6u,0x67u,0xeeu,0x34u,0x62u,0x6au,0x8bu,0xbu,0x28u,0xbeu,0x6eu,0xb9u,0x17u,0x27u,0x47u,0x74u,0x7u,0x26u,0xc6u,0x80u,0x10u,0x3fu,0xe0u,0xa0u,0x7eu,0x6fu,0xc6u,0x7eu,0x48u,0x7bu))
        11 -> UByteArrayScratchpad(ubyteArrayOf(0xdu,0x55u,0xau,0xa5u,0x4au,0xf8u,0xa4u,0xc0u,0x91u,0xe3u,0xe7u,0x9fu,0x97u,0x8eu,0xf1u,0x9eu,0x86u,0x76u,0x72u,0x81u,0x50u,0x60u,0x8du,0xd4u,0x7eu,0x9eu,0x5au,0x41u,0xf3u,0xe5u,0xb0u,0x62u))
        12 -> UByteArrayScratchpad(ubyteArrayOf(0xfcu,0x9fu,0x1fu,0xecu,0x40u,0x54u,0x20u,0x7au,0xe3u,0xe4u,0x1au,0x0u,0xceu,0xf4u,0xc9u,0x84u,0x4fu,0xd7u,0x94u,0xf5u,0x9du,0xfau,0x95u,0xd8u,0x55u,0x2eu,0x7eu,0x11u,0x24u,0xc3u,0x54u,0xa5u))
        13 -> UByteArrayScratchpad(ubyteArrayOf(0x5bu,0xdfu,0x72u,0x28u,0xbdu,0xfeu,0x6eu,0x28u,0x78u,0xf5u,0x7fu,0xe2u,0xfu,0xa5u,0xc4u,0xb2u,0x5u,0x89u,0x7cu,0xefu,0xeeu,0x49u,0xd3u,0x2eu,0x44u,0x7eu,0x93u,0x85u,0xebu,0x28u,0x59u,0x7fu))
        14 -> UByteArrayScratchpad(ubyteArrayOf(0x70u,0x5fu,0x69u,0x37u,0xb3u,0x24u,0x31u,0x4au,0x5eu,0x86u,0x28u,0xf1u,0x1du,0xd6u,0xe4u,0x65u,0xc7u,0x1bu,0x77u,0x4u,0x51u,0xb9u,0x20u,0xe7u,0x74u,0xfeu,0x43u,0xe8u,0x23u,0xd4u,0x87u,0x8au))
        15 -> UByteArrayScratchpad(ubyteArrayOf(0x7du,0x29u,0xe8u,0xa3u,0x92u,0x76u,0x94u,0xf2u,0xddu,0xcbu,0x7au,0x9u,0x9bu,0x30u,0xd9u,0xc1u,0x1du,0x1bu,0x30u,0xfbu,0x5bu,0xdcu,0x1bu,0xe0u,0xdau,0x24u,0x49u,0x4fu,0xf2u,0x9cu,0x82u,0xbfu))
        16 -> UByteArrayScratchpad(ubyteArrayOf(0xa4u,0xe7u,0xbau,0x31u,0xb4u,0x70u,0xbfu,0xffu,0xdu,0x32u,0x44u,0x5u,0xdeu,0xf8u,0xbcu,0x48u,0x3bu,0xaeu,0xfcu,0x32u,0x53u,0xbbu,0xd3u,0x39u,0x45u,0x9fu,0xc3u,0xc1u,0xe0u,0x29u,0x8bu,0xa0u))
        17 -> UByteArrayScratchpad(ubyteArrayOf(0xe5u,0xc9u,0x5u,0xfdu,0xf7u,0xaeu,0x9u,0xfu,0x94u,0x70u,0x34u,0x12u,0x42u,0x90u,0xf1u,0x34u,0xa2u,0x71u,0xb7u,0x1u,0xe3u,0x44u,0xedu,0x95u,0xe9u,0x3bu,0x8eu,0x36u,0x4fu,0x2fu,0x98u,0x4au))
        18 -> UByteArrayScratchpad(ubyteArrayOf(0x88u,0x40u,0x1du,0x63u,0xa0u,0x6cu,0xf6u,0x15u,0x47u,0xc1u,0x44u,0x4bu,0x87u,0x52u,0xafu,0xffu,0x7eu,0xbbu,0x4au,0xf1u,0xe2u,0xau,0xc6u,0x30u,0x46u,0x70u,0xb6u,0xc5u,0xccu,0x6eu,0x8cu,0xe6u))
        19 -> UByteArrayScratchpad(ubyteArrayOf(0xa4u,0xd5u,0xa4u,0x56u,0xbdu,0x4fu,0xcau,0x0u,0xdau,0x9du,0x84u,0x4bu,0xc8u,0x3eu,0x18u,0xaeu,0x73u,0x57u,0xceu,0x45u,0x30u,0x64u,0xd1u,0xadu,0xe8u,0xa6u,0xceu,0x68u,0x14u,0x5cu,0x25u,0x67u))
        20 -> UByteArrayScratchpad(ubyteArrayOf(0xa3u,0xdau,0x8cu,0xf2u,0xcbu,0xeu,0xe1u,0x16u,0x33u,0xe9u,0x6u,0x58u,0x9au,0x94u,0x99u,0x9au,0x1fu,0x60u,0xb2u,0x20u,0xc2u,0x6fu,0x84u,0x7bu,0xd1u,0xceu,0xacu,0x7fu,0xa0u,0xd1u,0x85u,0x18u))
        21 -> UByteArrayScratchpad(ubyteArrayOf(0x32u,0x59u,0x5bu,0xa1u,0x8du,0xddu,0x19u,0xd3u,0x50u,0x9au,0x1cu,0xc0u,0xaau,0xa5u,0xb4u,0x46u,0x9fu,0x3du,0x63u,0x67u,0xe4u,0x4u,0x6bu,0xbau,0xf6u,0xcau,0x19u,0xabu,0xbu,0x56u,0xeeu,0x7eu))
        22 -> UByteArrayScratchpad(ubyteArrayOf(0x1fu,0xb1u,0x79u,0xeau,0xa9u,0x28u,0x21u,0x74u,0xe9u,0xbdu,0xf7u,0x35u,0x3bu,0x36u,0x51u,0xeeu,0x1du,0x57u,0xacu,0x5au,0x75u,0x50u,0xd3u,0x76u,0x3au,0x46u,0xc2u,0xfeu,0xa3u,0x7du,0x70u,0x1u))
        23 -> UByteArrayScratchpad(ubyteArrayOf(0xf7u,0x35u,0xc1u,0xafu,0x98u,0xa4u,0xd8u,0x42u,0x78u,0xedu,0xecu,0x20u,0x9eu,0x6bu,0x67u,0x79u,0x41u,0x83u,0x63u,0x15u,0xeau,0x3au,0xdbu,0xa8u,0xfau,0xc3u,0x3bu,0x4du,0x32u,0x83u,0x2cu,0x83u))
        24 -> UByteArrayScratchpad(ubyteArrayOf(0xa7u,0x40u,0x3bu,0x1fu,0x1cu,0x27u,0x47u,0xf3u,0x59u,0x40u,0xf0u,0x34u,0xb7u,0x2du,0x76u,0x9au,0xe7u,0x3eu,0x4eu,0x6cu,0xd2u,0x21u,0x4fu,0xfdu,0xb8u,0xfdu,0x8du,0x39u,0xdcu,0x57u,0x59u,0xefu))
        25 -> UByteArrayScratchpad(ubyteArrayOf(0x8du,0x9bu,0xcu,0x49u,0x2bu,0x49u,0xebu,0xdau,0x5bu,0xa2u,0xd7u,0x49u,0x68u,0xf3u,0x70u,0xdu,0x7du,0x3bu,0xaeu,0xd0u,0x7au,0x8du,0x55u,0x84u,0xf5u,0xa5u,0xe9u,0xf0u,0xe4u,0xf8u,0x8eu,0x65u))
        26 -> UByteArrayScratchpad(ubyteArrayOf(0xa0u,0xb8u,0xa2u,0xf4u,0x36u,0x10u,0x3bu,0x53u,0xcu,0xa8u,0x7u,0x9eu,0x75u,0x3eu,0xecu,0x5au,0x91u,0x68u,0x94u,0x92u,0x56u,0xe8u,0x88u,0x4fu,0x5bu,0xb0u,0x5cu,0x55u,0xf8u,0xbau,0xbcu,0x4cu))
        27 -> UByteArrayScratchpad(ubyteArrayOf(0xe3u,0xbbu,0x3bu,0x99u,0xf3u,0x87u,0x94u,0x7bu,0x75u,0xdau,0xf4u,0xd6u,0x72u,0x6bu,0x1cu,0x5du,0x64u,0xaeu,0xacu,0x28u,0xdcu,0x34u,0xb3u,0x6du,0x6cu,0x34u,0xa5u,0x50u,0xb8u,0x28u,0xdbu,0x71u))
        28 -> UByteArrayScratchpad(ubyteArrayOf(0xf8u,0x61u,0xe2u,0xf2u,0x10u,0x8du,0x51u,0x2au,0xe3u,0xdbu,0x64u,0x33u,0x59u,0xddu,0x75u,0xfcu,0x1cu,0xacu,0xbcu,0xf1u,0x43u,0xceu,0x3fu,0xa2u,0x67u,0xbbu,0xd1u,0x3cu,0x2u,0xe8u,0x43u,0xb0u))
        29 -> UByteArrayScratchpad(ubyteArrayOf(0x33u,0xau,0x5bu,0xcau,0x88u,0x29u,0xa1u,0x75u,0x7fu,0x34u,0x19u,0x4du,0xb4u,0x16u,0x53u,0x5cu,0x92u,0x3bu,0x94u,0xc3u,0xeu,0x79u,0x4du,0x1eu,0x79u,0x74u,0x75u,0xd7u,0xb6u,0xeeu,0xafu,0x3fu))
        30 -> UByteArrayScratchpad(ubyteArrayOf(0xeau,0xa8u,0xd4u,0xf7u,0xbeu,0x1au,0x39u,0x21u,0x5cu,0xf4u,0x7eu,0x9u,0x4cu,0x23u,0x27u,0x51u,0x26u,0xa3u,0x24u,0x53u,0xbau,0x32u,0x3cu,0xd2u,0x44u,0xa3u,0x17u,0x4au,0x6du,0xa6u,0xd5u,0xadu))
        31 -> UByteArrayScratchpad(ubyteArrayOf(0xb5u,0x1du,0x3eu,0xa6u,0xafu,0xf2u,0xc9u,0x8u,0x83u,0x59u,0x3du,0x98u,0x91u,0x6bu,0x3cu,0x56u,0x4cu,0xf8u,0x7cu,0xa1u,0x72u,0x86u,0x60u,0x4du,0x46u,0xe2u,0x3eu,0xccu,0x8u,0x6eu,0xc7u,0xf6u))
        32 -> UByteArrayScratchpad(ubyteArrayOf(0x2fu,0x98u,0x33u,0xb3u,0xb1u,0xbcu,0x76u,0x5eu,0x2bu,0xd6u,0x66u,0xa5u,0xefu,0xc4u,0xe6u,0x2au,0x6u,0xf4u,0xb6u,0xe8u,0xbeu,0xc1u,0xd4u,0x36u,0x74u,0xeeu,0x82u,0x15u,0xbcu,0xefu,0x21u,0x63u))
        33 -> UByteArrayScratchpad(ubyteArrayOf(0xfdu,0xc1u,0x4eu,0xdu,0xf4u,0x53u,0xc9u,0x69u,0xa7u,0x7du,0x5au,0xc4u,0x6u,0x58u,0x58u,0x26u,0x7eu,0xc1u,0x14u,0x16u,0x6u,0xe0u,0xfau,0x16u,0x7eu,0x90u,0xafu,0x3du,0x28u,0x63u,0x9du,0x3fu))
        34 -> UByteArrayScratchpad(ubyteArrayOf(0xd2u,0xc9u,0xf2u,0xe3u,0x0u,0x9bu,0xd2u,0xcu,0x5fu,0xaau,0xceu,0x30u,0xb7u,0xd4u,0xcu,0x30u,0x74u,0x2au,0x51u,0x16u,0xf2u,0xe0u,0x32u,0x98u,0xdu,0xebu,0x30u,0xd8u,0xe3u,0xceu,0xf8u,0x9au))
        35 -> UByteArrayScratchpad(ubyteArrayOf(0x4bu,0xc5u,0x9eu,0x7bu,0xb5u,0xf1u,0x79u,0x92u,0xffu,0x51u,0xe6u,0x6eu,0x4u,0x86u,0x68u,0xd3u,0x9bu,0x23u,0x4du,0x57u,0xe6u,0x96u,0x67u,0x31u,0xccu,0xe6u,0xa6u,0xf3u,0x17u,0xau,0x75u,0x5u))
        36 -> UByteArrayScratchpad(ubyteArrayOf(0xb1u,0x76u,0x81u,0xd9u,0x13u,0x32u,0x6cu,0xceu,0x3cu,0x17u,0x52u,0x84u,0xf8u,0x5u,0xa2u,0x62u,0xf4u,0x2bu,0xcbu,0xb3u,0x78u,0x47u,0x15u,0x47u,0xffu,0x46u,0x54u,0x82u,0x23u,0x93u,0x6au,0x48u))
        37 -> UByteArrayScratchpad(ubyteArrayOf(0x38u,0xdfu,0x58u,0x7u,0x4eu,0x5eu,0x65u,0x65u,0xf2u,0xfcu,0x7cu,0x89u,0xfcu,0x86u,0x50u,0x8eu,0x31u,0x70u,0x2eu,0x44u,0xd0u,0xbu,0xcau,0x86u,0xf0u,0x40u,0x9u,0xa2u,0x30u,0x78u,0x47u,0x4eu))
        38 -> UByteArrayScratchpad(ubyteArrayOf(0x65u,0xa0u,0xeeu,0x39u,0xd1u,0xf7u,0x38u,0x83u,0xf7u,0x5eu,0xe9u,0x37u,0xe4u,0x2cu,0x3au,0xbdu,0x21u,0x97u,0xb2u,0x26u,0x1u,0x13u,0xf8u,0x6fu,0xa3u,0x44u,0xedu,0xd1u,0xefu,0x9fu,0xdeu,0xe7u))
        39 -> UByteArrayScratchpad(ubyteArrayOf(0x8bu,0xa0u,0xdfu,0x15u,0x76u,0x25u,0x92u,0xd9u,0x3cu,0x85u,0xf7u,0xf6u,0x12u,0xdcu,0x42u,0xbeu,0xd8u,0xa7u,0xecu,0x7cu,0xabu,0x27u,0xb0u,0x7eu,0x53u,0x8du,0x7du,0xdau,0xaau,0x3eu,0xa8u,0xdeu))
        40 -> UByteArrayScratchpad(ubyteArrayOf(0xaau,0x25u,0xceu,0x93u,0xbdu,0x2u,0x69u,0xd8u,0x5au,0xf6u,0x43u,0xfdu,0x1au,0x73u,0x8u,0xf9u,0xc0u,0x5fu,0xefu,0xdau,0x17u,0x4au,0x19u,0xa5u,0x97u,0x4du,0x66u,0x33u,0x4cu,0xfdu,0x21u,0x6au))
        else -> UByteArrayScratchpad(ubyteArrayOf(0x35u,0xb4u,0x98u,0x31u,0xdbu,0x41u,0x15u,0x70u,0xeau,0x1eu,0xfu,0xbbu,0xedu,0xcdu,0x54u,0x9bu,0x9au,0xd0u,0x63u,0xa1u,0x51u,0x97u,0x40u,0x72u,0xf6u,0x75u,0x9du,0xbfu,0x91u,0x47u,0x6fu,0xe2u))
    }}
    private fun SWAP1(x: ULong) = ((((x) and 0x5555555555555555uL) shl 1) or (((x) and 0xaaaaaaaaaaaaaaaauL) shr 1))
    /*swapping bits 4ioror4i+1 with bits 4i+2oror4i+3 of 64-bit x*/
    private fun SWAP2(x: ULong) = ((((x) and 0x3333333333333333uL) shl 2) or (((x) and 0xccccccccccccccccuL) shr 2))

    /*swapping bits 8ioror8i+1oror8i+2oror8i+3 with bits 8i+4oror8i+5oror8i+6oror8i+7 of 64-bit x*/
    private fun SWAP4(x: ULong) = ((((x) and 0x0f0f0f0f0f0f0f0fuL) shl 4) or (((x) and 0xf0f0f0f0f0f0f0f0uL) shr 4))

    /*swapping bits 16ioror16i+1oror......oror16i+7  with bits 16i+8oror16i+9oror......oror16i+15 of 64-bit x*/
    private fun SWAP8(x: ULong) = ((((x) and 0x00ff00ff00ff00ffuL) shl 8) or (((x) and 0xff00ff00ff00ff00uL) shr 8))

    /*swapping bits 32ioror32i+1oror......oror32i+15 with bits 32i+16oror32i+17oror......oror32i+31 of 64-bit x*/
    private fun SWAP16(x: ULong) = ((((x) and 0x0000ffff0000ffffuL) shl 16) or (((x) and 0xffff0000ffff0000uL) shr 16))

    /*swapping bits 64ioror64i+1oror......oror64i+31 with bits 64i+32oror64i+33oror......oror64i+63 of 64-bit x*/
    private fun SWAP32(x: ULong) = (((x) shl 32) or ((x) shr 32))

    private fun L(x: Array<ULongArray>, i: Int){
        x[1][i] = x[1][i] xor x[2][i]
        x[3][i] = x[3][i] xor x[4][i]
        x[5][i] = x[5][i] xor x[0][i] xor x[6][i]
        x[7][i] = x[7][i] xor x[0][i]
        x[0][i] = x[0][i] xor x[3][i]
        x[2][i] = x[2][i] xor x[5][i]
        x[4][i] = x[4][i] xor x[1][i] xor x[7][i]
        x[6][i] = x[6][i] xor x[1][i]
    }

    private fun SS(x: Array<ULongArray>, i: Int, cc0: ULong, cc1: ULong){
        x[6][i] = x[6][i].inv()
        x[7][i] = x[7][i].inv()
        x[0][i] = x[0][i] xor (x[4][i].inv() and cc0)
        x[1][i] = x[1][i] xor (x[5][i].inv() and cc1)
        val temp0 = cc0 xor (x[0][i] and x[2][i])
        val temp1 = cc1 xor (x[1][i] and x[3][i])
        x[0][i] = x[0][i] xor (x[4][i] and x[6][i])
        x[1][i] = x[1][i] xor (x[5][i] and x[7][i])
        x[6][i] = x[6][i] xor (x[2][i].inv() and x[4][i])
        x[7][i] = x[7][i] xor (x[3][i].inv() and x[5][i])
        x[2][i] = x[2][i] xor (x[0][i] and x[4][i])
        x[3][i] = x[3][i] xor (x[1][i] and x[5][i])
        x[4][i] = x[4][i] xor (x[0][i] and x[6][i].inv())
        x[5][i] = x[5][i] xor (x[1][i] and x[7][i].inv())
        x[0][i] = x[0][i] xor (x[2][i] or x[6][i])
        x[1][i] = x[1][i] xor (x[3][i] or x[7][i])
        x[6][i] = x[6][i] xor (x[2][i] and x[4][i])
        x[7][i] = x[7][i] xor (x[3][i] and x[5][i])
        x[2][i] = x[2][i] xor (temp0 and x[0][i])
        x[3][i] = x[3][i] xor (temp1 and x[1][i])
        x[4][i] = x[4][i] xor temp0
        x[5][i] = x[5][i] xor temp1
    }

    private fun E8(state: JHHashState){
        for (roundnumber in 0 until 42 step 7) {
            /*round 7*roundnumber+0: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+0].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2])
                L(state.x, i)
                state.x[1][i] = SWAP1(state.x[1][i])
                state.x[3][i] = SWAP1(state.x[3][i])
                state.x[5][i] = SWAP1(state.x[5][i])
                state.x[7][i] = SWAP1(state.x[7][i])
            }

            /*round 7*roundnumber+1: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+1].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
                state.x[1][i] = SWAP2(state.x[1][i])
                state.x[3][i] = SWAP2(state.x[3][i])
                state.x[5][i] = SWAP2(state.x[5][i])
                state.x[7][i] = SWAP2(state.x[7][i])

            }

            /*round 7*roundnumber+2: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+2].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
                state.x[1][i] = SWAP4(state.x[1][i])
                state.x[3][i] = SWAP4(state.x[3][i])
                state.x[5][i] = SWAP4(state.x[5][i])
                state.x[7][i] = SWAP4(state.x[7][i])

            }

            /*round 7*roundnumber+3: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+3].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
                state.x[1][i] = SWAP8(state.x[1][i])
                state.x[3][i] = SWAP8(state.x[3][i])
                state.x[5][i] = SWAP8(state.x[5][i])
                state.x[7][i] = SWAP8(state.x[7][i])

            }

            /*round 7*roundnumber+4: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+4].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
                state.x[1][i] = SWAP16(state.x[1][i])
                state.x[3][i] = SWAP16(state.x[3][i])
                state.x[5][i] = SWAP16(state.x[5][i])
                state.x[7][i] = SWAP16(state.x[7][i])

            }

            /*round 7*roundnumber+5: Sbox, MDS and Swapping layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+5].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
                state.x[1][i] = SWAP32(state.x[1][i])
                state.x[3][i] = SWAP32(state.x[3][i])
                state.x[5][i] = SWAP32(state.x[5][i])
                state.x[7][i] = SWAP32(state.x[7][i])

            }

            /*round 7*roundnumber+6: Sbox and MDS layers*/
            for (i in 0 until 2) {
                val bp = E8_bitslice_roundconstant[roundnumber+6].getPointer(0).toULongPointer()
                SS(state.x, i,bp[i],bp[i+2] )
                L(state.x, i)
            }
            /*round 7*roundnumber+6: swapping layer*/
            for (i in 1 until 8 step 2) {
                val temp0 = state.x[i][0]
                state.x[i][0] = state.x[i][1]
                state.x[i][1] = temp0
            }
        }
    }

    private fun F8(state: JHHashState){
        /*xor the 512-bit message with the fist half of the 1024-bit hash state*/
        for (i in 0 until 8){
            state.x[i shr 1][i and 1] = state.x[i shr 1][i and 1] xor state.bpl[i]
        }

        /*the bijective function E8 */
        E8(state)

        /*xor the 512-bit message with the second half of the 1024-bit hash state*/
        for (i in 0 until 8){
            state.x[(8+i) shr 1][(8+i) and 1] = state.x[(8+i) shr 1][(8+i) and 1] xor state.bpl[i]
        }
    }

    private fun Init(state: JHHashState, hashbitlen: Int)
    {
        state.databitlen = 0
        state.datasize_in_buffer = 0

        /*initialize the initial hash value of JH*/
        state.hashbitlen = hashbitlen

        /*load the intital hash value into state*/
        val tv = UByteArrayScratchpad(JH256_H0).getPointer(0).toULongPointer()
        for(i in 0 until 8){
            for(j in 0 until 2){
                state.x[i][j] = tv[(i * 2) + j]
            }
        }
        //memcpy(state->x,JH256_H0,128)
    }
    private fun Update(state: JHHashState, data: UBytePointer, databitlen_: ULong)
    {
        var databitlen = databitlen_.toInt()
        var index = 0 /*the starting address of the data to be compressed*/

        state.databitlen += databitlen

        /*if there is remaining data in the buffer, fill it to a full message block first*/
        /*we assume that the size of the data in the buffer is the multiple of 8 bits if it is not at the end of a message*/

        /*There is data in the buffer, but the incoming data is insufficient for a full block*/
        if ( (state.datasize_in_buffer > 0 ) && (( state.datasize_in_buffer + databitlen) < 512)  ) {
            if ( (databitlen and 7) == 0 ) {
                state.buffer[state.datasize_in_buffer shr 3] = data[0, 64-(state.datasize_in_buffer shr 3)]
                //memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)) ;
            }else{
                state.buffer[state.datasize_in_buffer shr 3] = data[0, 64-(state.datasize_in_buffer shr 3) + 1]
                //memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)+1) ;
            }
            state.datasize_in_buffer += databitlen
            databitlen = 0
        }

        /*There is data in the buffer, and the incoming data is sufficient for a full block*/
        if ( (state.datasize_in_buffer > 0 ) && (( state.datasize_in_buffer + databitlen) >= 512)  ) {
            state.buffer[state.datasize_in_buffer shr 3] = data[0, 64-(state.datasize_in_buffer shr 3)]
            //memcpy( state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3) ) ;
            index = 64-(state.datasize_in_buffer shr 3)
            databitlen -= (512 - state.datasize_in_buffer)
            F8(state)
            state.datasize_in_buffer = 0
        }

        /*hash the remaining full message blocks*/
        while(databitlen >= 512){
            state.buffer[0] = data[index, 64]
            //memcpy(state->buffer, data+index, 64);
            F8(state)
            index += 64
            databitlen -= 512
        }

        /*store the partial block into buffer, assume that -- if part of the last byte is not part of the message, then that part consists of 0 bits*/
        if ( databitlen > 0) {
            if ((databitlen and 7) == 0){
                state.buffer[0] = data[index, (databitlen and 0x1ff) shr 3]
                //memcpy(state->buffer, data+index, (databitlen & 0x1ff) >> 3);
            }else{
                state.buffer[0] = data[index, ((databitlen and 0x1ff) shr 3) + 1]
                //memcpy(state->buffer, data+index, ((databitlen & 0x1ff) >> 3)+1);
            }
            state.datasize_in_buffer = databitlen
        }
    }

    private fun Final(state: JHHashState, hashval: UBytePointer)
    {
        if ( (state.databitlen and 0x1ff) == 0 ) {
            /*pad the message when databitlen is multiple of 512 bits, then process the padded block*/
            state.buffer[0] = UByteArray(64)
            //memset(state.buffer, 0, 64);

            state.buffer[0] = 0x80u
            state.buffer[63] = (state.databitlen.toULong() and 0xffuL).toUByte()
            state.buffer[62] = (state.databitlen.toULong() shr 8 and 0xffu).toUByte()
            state.buffer[61] = (state.databitlen.toULong() shr 16 and 0xffu).toUByte()
            state.buffer[60] = (state.databitlen.toULong() shr 24 and 0xffu).toUByte()
            state.buffer[59] = (state.databitlen.toULong() shr 32 and 0xffu).toUByte()
            state.buffer[58] = (state.databitlen.toULong() shr 40 and 0xffu).toUByte()
            state.buffer[57] = (state.databitlen.toULong() shr 48 and 0xffu).toUByte()
            state.buffer[56] = (state.databitlen.toULong() shr 56 and 0xffu).toUByte()
            F8(state)
        }else {
            /*set the rest of the bytes in the buffer to 0*/

            if ( (state.datasize_in_buffer and 7) == 0){
                for (i in (state.databitlen and 0x1ff) shr 3 until 64)
                    state.buffer[i] = 0u
            }else{
                for (i in ((state.databitlen and 0x1ff) shr 3)+1 until 64)
                    state.buffer[i] = 0u
            }

            /*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
            state.buffer[((state.databitlen and 0x1ff) shr 3)] = state.buffer[((state.databitlen and 0x1ff) shr 3)] or (1 shl (7- (state.databitlen and 7))).toUByte()

            F8(state)
            state.buffer[0] = UByteArray(64)
            //memset(state.buffer, 0, 64);
            state.buffer[63] = (state.databitlen.toULong() and 0xffu).toUByte()
            state.buffer[62] = (state.databitlen.toULong() shr 8 and 0xffu).toUByte()
            state.buffer[61] = (state.databitlen.toULong() shr 16 and 0xffu).toUByte()
            state.buffer[60] = (state.databitlen.toULong() shr 24 and 0xffu).toUByte()
            state.buffer[59] = (state.databitlen.toULong() shr 32 and 0xffu).toUByte()
            state.buffer[58] = (state.databitlen.toULong() shr 40 and 0xffu).toUByte()
            state.buffer[57] = (state.databitlen.toULong() shr 48 and 0xffu).toUByte()
            state.buffer[56] = (state.databitlen.toULong() shr 56 and 0xffu).toUByte()
            F8(state)
        }
        for(i in 6 until 8){
            for(j in 0 until 2){
                hashval.toULongPointer()[((i - 6) * 2) + j] = state.x[i][j]
            }
        }
        //memcpy(hashval,(unsigned char*)state->x+64+32,32);
    }

    private fun jh_hash(hashbitlen: Int, data: UBytePointer, databitlen: Int, hashval: UBytePointer) {
        val state = JHHashState(0, databitlen, 0)

        Init(state, hashbitlen)
        Update(state, data, databitlen.toULong())
        Final(state, hashval)
    }

    fun hash_extra_jh(data: UBytePointer, length: Int, hash: UBytePointer) {
        jh_hash(32 * 8, data, 8 * length, hash)
    }
}